# 그래프 - 순위

## 문제
https://school.programmers.co.kr/learn/courses/30/lessons/49191

## 문제접근
- 그래프 최단거리 문제 (경로문제)
- 경기 결과의 순위를 정확하게 매길 수 있는 선수의 수
- 플로이드-워셜 원리 이용해서 접근
  - 시작지점이 없음.
  - 모든 노드의 쌍 간에 결과를 구해야함.
  - 노드의 개수가 작음.
- 위상정렬로 풀어야 하는 지 착각함. 
  - 위상정렬은 사이클이 없는 간선의 방향이 존재하는 그래프일 때 사용.

## 문제풀이
- 모든 노드에서 내가 이기는 노드와 이기는 노드가 이기는 노드를 찾아내서 모든 경우를 갱신
- 플로이드-워셜 알고리즘의 3중 반복문을 이용해서 사용한다.
    ```java
    for (int k = 0; k < n; k++) { // 경유지
        for (int s = 0; s < n ; s++) { // 출발
            for (int e = 0; e < n; e++) {  // 도착
                // 출발노드가 경유지노드를 이기고, 경유지노드가 도착지노드를 이기는 경우 (도착 < 경유 < 출발)
                if (graph[s][k] == 1 && graph[k][e] == 1) {
                    graph[s][e] = 1; // 출발노드가 도착노드를 이긴다.
                    graph[e][s] = -1;  // 도착노드는 출발도느에게 진다.
                }
                // 출발노드가 경유지노드에 지고, 경유지노드는 도착지노드를 지는 경우 (출발 < 경유 < 도착)
                if (graph[s][k] == -1 && graph[k][e] == -1) {
                    graph[s][e] = -1; // 출발노드는 도착노드에게 진다.
                    graph[e][s] = 1; // 도착노드는 출발노드를 이긴다.
                }
            }
        }
    }
    ```
  - 1번은 2번을 이긴다. 2번은 5번을 이긴다. 
    - 1번은 5번을 무조건 이긴다.
    - 5번은 1번을 무조건 진다.
  - 4번은 3번에게 진다. 1번은 4번에게 진다.
    - 1번은 3번에게 무조건 진다.
    - 3번은 1번을 무조건 이긴다.
  - 이렇게 모든 노드들을 돌면서 갱신해줍니다.
  ```java
  int answer = 0;
  for (int i = 0; i < n; i++) {
      int count = 0;
      for (int j = 0; j < n; j++) {
          if (graph[i][j] !=0) count++; // 자기자신은 제외
      }
      if (count == n-1) answer++; // n-1의 뜻은 자기자신 외 다른노드와의 게임 결과가 있다는 뜻.
  }
  ```
  - 자기 자신을 제외하고 자기 자신과 게임결과가 존재한다면 카운딩 